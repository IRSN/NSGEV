% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/checkFuns.R
\name{check_predictUncond}
\alias{check_predictUncond}
\title{Check the \code{\link{predictUncond}} Function}
\usage{
check_predictUncond(
  object,
  newdateFrom = "2020-01-01",
  nsim = 5000,
  plot = TRUE,
  trace = 0,
  ...
)
}
\arguments{
\item{object}{An object with class \code{"TVGEV"}}

\item{newdateFrom}{Argument passed to \code{\link{predictUncond}}.}

\item{nsim}{Number os simulations to use in in the check.}

\item{plot}{Logical. If \code{TRUE}, some simulated paths will be
shown.}

\item{trace}{Integer level of verbosity.}

\item{...}{Other arguments to be passed to \code{\link{predictUncond}}.}
}
\value{
A vector of average number of exceedances corresponding to
each of the periods which have been predicted. The elemnts of this
vector should be close to one, see \bold{Details}.
}
\description{
Check the 'predictUncond' function.
}
\details{
The unconditional prediction is computed from the object given
using \code{predictUncond} this leads to a table, say
\code{pu}. Then \code{nsim} paths are simulated from the model;
The simulation is for the period of time begining at
\code{newdateFrom} and having the length suitable to cover all the
predicted periods found in \code{pu}. For each row of the
prediction table \code{pu} -by default, corresponding to a period 5, 10, 20,
...- we count the number of exceedances over the quantile given in
the \code{'Quant'} column, for each sample. By definition of the
Non-Stationary Return Level, the random number of exceedances has
an expectation of one. The function returns the average numbers of
exceedances over the \code{nsim} paths which therefore should be
close to one at least if \code{nsim} is large.
}
\examples{
example(TVGEV)
set.seed(1357)
check_predictUncond(res2)
check_predictUncond(res2, newdateFrom = "1900-01-01", period = 200)

}
\seealso{
\code{\link{predictUncond}}.
}
