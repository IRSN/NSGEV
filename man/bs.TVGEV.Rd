% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TVGEV.R
\name{bs.TVGEV}
\alias{bs.TVGEV}
\title{Bootstrap for a \code{TVGEV} Model}
\usage{
\method{bs}{TVGEV}(object, R = 100, type = c("param", "NP"),
  estim = "optim", parallel = FALSE, ...)
}
\arguments{
\item{object}{A \code{TVGEV} object.}

\item{R}{Target number of bootstrap samples.}

\item{type}{Character. The values \code{"param"} and \code{"NP"}
can be used to chose between parametric and nonparametric bootstrap,
see \bold{Details}.}

\item{estim}{Argument passed to \code{MLE}.}

\item{parallel}{Logical. If \code{TRUE} the loop over the bootstrap
sample is performed using \code{foreach} with \code{\%do par\%}.}

\item{...}{Further arguments passed to \code{MLE}.}
}
\value{
A matrix containing the bootstraped parameter vectors,
with one row for each bootstrap sample.
}
\description{
Bootstrap for a \code{TVGEV} model.
}
\details{
The parametric bootstrap (\code{type = "param"}) is as follows: for
each bootstrap sample, a response vector
\eqn{\mathbf{y}^\star}{y*} is drawn from the estimated GEV
distribution as described in \code{object}; a MLE is performed to
find the bootstraped parameter vector
\eqn{\boldsymbol{\psi}^\star}{\psi*}. For the nonparametric
bootstrap (\code{type = "NP"}), the generalised residuals of the
object as returned by \code{\link{residuals.TVGEV}} are resampled
and are back-transformed to simulated observations; a MLE is then
performed to find the bootstraped parameter vector
\eqn{\boldsymbol{\psi}^\star}{\psi*} as in the parametric case.
}
\note{
The simulated response does not cover the observations where
the original response was \code{NA}.
}
\section{Caution}{
 For some bootstrap samples, the MLE may fail, in
which case the coefficients will be ignored. So the true number
of sampled coefficient vecors  will generally be smaller than the
target number as given in \code{R}.
}

\examples{

example(TVGEV)
bsb <- bs(res2, R = 50, estim = "nloptr")

\dontrun{
   library(parallel)
   library(doParallel)
   nc <- detectCores()
   cl <- makeCluster(nc)
   registerDoParallel(cl)

   ## findings: with 'nloptr', less than 1\% of the optimisations
   ## diverges, while more than 10\% diverged with 'optim'.
   te <- system.time(bspb <- bs(res2, R = 5000, estim = "nloptr",
                                parallel = TRUE))
   stopCluster(cl) 
}

## add the 'bs' results to the model object as 'boot' element,
## in order to facilitate the prediction. The number of
## bootstrap replicates in the prediction will correspond
## to the number of replications stored in the model object,
## an no longer to the default

res2$boot <- bsb
predict(res2, confintMethod = "boot")

}
