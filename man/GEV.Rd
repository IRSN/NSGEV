% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GEV.R
\name{GEV}
\alias{GEV}
\alias{dGEV}
\alias{pGEV}
\alias{qGEV}
\alias{rGEV}
\title{Density, Distribution Function, Quantile Function and
Random Generation for the Generalized Extreme Value (GEV)
Distribution}
\usage{
dGEV(x, loc = 0, scale = 1, shape = 0, log = FALSE,
  deriv = FALSE, hessian = FALSE, impl = c("C", "R"))

pGEV(q, loc = 0, scale = 1, shape = 0, lower.tail = TRUE,
  deriv = FALSE, impl = c("C", "R"))

qGEV(p, loc = 0, scale = 1, shape = 0, lower.tail = TRUE,
  deriv = FALSE, hessian = FALSE, impl = c("C", "R"))

rGEV(n, loc = 0, scale = 1, shape = 0)
}
\arguments{
\item{x, q}{Vector of quantiles.}

\item{loc}{Location parameter. Numeric vector with suitable
length, see \bold{Details}.}

\item{scale}{Scale parameter. Numeric vector with suitable length,
see \bold{Details}.}

\item{shape}{Shape parameter. Numeric vector with suitable length,
see \bold{Details}.}

\item{log}{Logical; if \code{TRUE}, densities \code{p} are
returned as \code{log(p)}.}

\item{deriv}{Logical. If \code{TRUE}, the gradient of each
computed value w.r.t. the parameter vector is computed, and
returned as a \code{"gradient"} attribute of the result. This is a
numeric array with dimension \code{c(n, 3)} where \code{n} is the
length of the first argument, i.e. \code{x}, \code{p} or \code{q}
depending on the function.}

\item{hessian}{Logical. If \code{TRUE}, the Hessian of each
computed value w.r.t. the parameter vector is computed, and
returned as a \code{"hessian"} attribute of the result. This is a
numeric array with dimension \code{c(n, 3, 3)} where \code{n} is
the length of the first argument, i.e. \code{x}, \code{p} or
depending on the function.}

\item{impl}{Character. Choose between a R and a C
implementation. The second one should be faster but less checks
have been done on it for now.}

\item{lower.tail}{Logical; if \code{TRUE} (default), probabilities are
P[X <= x], otherwise, P[X > x].}

\item{p}{Vector of probabilities.}

\item{n}{Sample size.}
}
\value{
A numeric vector with length equal to the length of the
first argument or of the parameters. When \code{deriv} is
\code{TRUE}, the returned value has an attribute named
\code{"gradient"} which is a matrix with \eqn{n} lines and \eqn{3}
columns containing the derivatives. A row contains the partial
derivatives of the corresponding element w.r.t. the three
parameters \code{loc} \code{scale} and \code{shape} in that order.
}
\description{
Density, distribution function, quantile function and random
generation for the Generalized Extreme Value (GEV) distribution
with parameters \code{loc}, \code{scale} and \code{shape}.
}
\details{
For the \code{d}, \code{p} and \code{q} functions, let
\code{n} be the length of the first element. If \code{n > 1}, then
each of the parameters \code{loc}, \code{scale} and \code{shape}
must be of length \code{1} or \code{n}: in the first case, it will
be recycled to have length \code{n}. When \code{n = 1} the largest
length met for the three parameters, say \code{np} is used. The
two other parameters must then be of length \code{1} or \code{np},
and are given the length \code{np}, as well as the first argument.
Note that only vectors of length one are actually recycled.
}
\note{
With the R implementation, the gradient and Hessian of the
(log) density can be \code{NaN} in the Gumbel case, i.e. when
\code{shape} has a small absolute value. This occurs when \eqn{z
:= (x - \mu) / \sigma} is strongly negative, say \eqn{z < -20} and
is due to numeric difficulties in operations involving very small
and very large values. This is fixed in the C implementation which
should be preferred.
}
\examples{
ti <- 1:10; names(ti) <- 2000 + ti
mu <- 1.0 + 0.1 * ti
## simulate 40 paths
y <- rGEV(n = 40, loc = mu, scale = 1, shape = 0.05)
matplot(ti, y, type = "l", col = "gray")
lines(ti, apply(y, 1, mean))
}
\author{
Yves Deville
}
