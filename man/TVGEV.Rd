% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TVGEV.R
\name{TVGEV}
\alias{TVGEV}
\title{Time-Varying GEV Model.}
\usage{
TVGEV(data, date, response, design = NULL, loc = ~1, scale = ~1,
  shape = ~1, psi0 = NULL, estim = c("optim", "nloptr", "none"),
  parTrack = FALSE, trace = 0)
}
\arguments{
\item{data}{A data frame containing at least the two required
variables with their names given in \code{date} and
\code{response}.}

\item{date}{Character. Name of the date variable in \code{data}.}

\item{response}{Character. Name of the response variable in
\code{data}.}

\item{design}{A call to a function creating a data frame with all
the variables required in the formulas \code{loc}, \code{scale}
and \code{shape}. While the content of \code{data} is mainly used
for the creation of the \code{TVGEV} object, \code{design} will be
used in prediction or computation of Return Levels.}

\item{loc}{A formula linking linearly the GEV location parameter
to the columns in the data frame created with \code{design}. The
Rogers-Wilkinson style of formula is used here (as in \code{lm}):
only the variables are given, the parameter names are created in
relation to the variables names.}

\item{scale}{A formula for the GEV scale parameter.}

\item{shape}{A formula for the GEV shape parameter.}

\item{psi0}{A numeric vector of initial values for the parameters.
By default a vector is computed using a linear model.}

\item{estim}{Character giving the package or function to be used
for the likelihood maximisation.}

\item{parTrack}{Logical. If \code{TRUE} the value of the parameter
vector is tracked during the optimisation (i.e. at each call of
the objective) and all the values are returned as a matrix
\code{"psi"} in a list named \code{"tracked"} which contains as
well the value of the objective.}

\item{trace}{Integer level of verbosity.}
}
\value{
An object with class \code{"TVGEV"}, a list. Among the
list elements

\item{call}{The call. This will be required.}

\item{data, design, loc, scale, shape}{Copies of the inputs.}

\item{response, date}{The \emph{name} of the response and of the
date columns in \code{data}.}

\item{terms}{A list with the terms for the three GEV parameters.}

\item{opt}{The results of the optimisation, if relevant.}

\item{estimates}{The numeric vector of estimates for the vector
\code{psi}.}

\item{theta}{A matrix with three columns containing the GEV
parameters \code{loc}, \code{scale} and \code{shape}.}
}
\description{
Time-varying GEV model
}
\details{
This kind of model describe \emph{independent} observations having
a Generalized Extreme Value (GEV) distribution depending on time.
The three GEV parameters (\code{"location"}, \code{"scale"} and
\code{"shape"}) can depend on a date variable used as a covariate
in a linear-model style of dependence. The covariates of the model
are functions of the date as provided in \code{breaksX},
\code{polynomX}, \code{trigonX}. No other covariates can be used
unless the use of \code{predict} or \code{RL} will not be possible.
}
\note{
When the response contains NA, the corresponding elements
are discarded in the computation of the log-likelihood. However the
corresponding rows exist in the matrix \code{theta}.
}
\section{Caution}{
 The call passed in the \code{design} formal will
be reused in prediction. Passing a merely data frame would make
prediction impossible because there would then be no way to guess
how the covariates of the model were created from the date.
}

\examples{

## transform a numeric year into a date
df <- within(TXMax_Dijon, Date <- as.Date(sprintf("\%4d-01-01", Year)))
df0 <- subset(df, !is.na(TXMax))

## fit a TVGEV model. Only the location parameter is TV.
t1 <- system.time(
    res1 <- TVGEV(data = df, response = "TXMax", date = "Date",
                  design = breaksX(date = Date, breaks = "1970-01-01", degree = 1),
                  loc = ~ t1 + t1_1970))

## The same using "nloptr" optimisation.
t2 <- system.time(
    res2 <- TVGEV(data = df, response = "TXMax", date = "Date",
                  design = breaksX(date = Date, breaks = "1970-01-01", degree = 1),
                  loc = ~ t1 + t1_1970,
                  estim = "nloptr",
                  parTrack = TRUE))

## use extRemes::fevd the required variables need to be added to the data frame
## passed as 'data' argument
t0 <- system.time({
   df0.evd <- cbind(df0, breaksX(date = df0$Date, breaks = "1970-01-01",
                    degree = 1));
   res0 <- fevd(x = df0.evd$TXMax, data = df0.evd, loc = ~ t1 + t1_1970)
 })

## compare estimates and negative log-liks
cbind("fevd" = res0$results$par,
      "TVGEV_optim" = res1$estimates,
      "TVGEV_nloptr" = res2$estimates)
cbind("fevd" = res0$results$value,
      "VGEV_optim" = res1$negLogLik,
      "TVGEV_nloptr" = res2$negLogLik)

## ====================================================================
## use a loop on plausible break years. The fitted models
## are stored within a list
## ====================================================================

\dontrun{

    yearBreaks <- c(1940, 1950, 1955, 1960:2000, 2005, 2010)
    res <- list()

    for (ib in seq_along(yearBreaks)) {
        d <- sprintf("\%4d-01-01", yearBreaks[[ib]])
        floc <- as.formula(sprintf("~ t1 + t1_\%4d", yearBreaks[[ib]]))
        res[[d]] <- TVGEV(data = df, response = "TXMax", date = "Date",
        design = breaksX(date = Date, breaks = d, degree = 1),
        loc = floc)
    }

    ## [continuing...] ]find the model with maximum likelihood, and plot
    ## something like a profile likelihood for the break date considered
    ## as a new parameter. However, the model is not differentiable w.r.t.
    ## the break! 

    ll <- sapply(res, logLik)
    plot(yearBreaks, ll, type = "o", pch = 21, col = "orangered",
         lwd = 2, bg = "gold", xlab = "break", ylab = "log-lik")
    grid()
    iMax <- which.max(ll)
    abline(v = yearBreaks[iMax])
    abline(h = ll[iMax] - c(0, qchisq(0.95, df = 1) /2),
           col = "SpringGreen3", lwd = 2)

}
}
\author{
Yves Deville
}
