<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Time-Varying Models in NSGEV • NSGEV</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Time-Varying Models in NSGEV">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">NSGEV</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.2.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/IntroTVGEV.html">Time-Varying Models in NSGEV</a>
    </li>
    <li>
      <a href="../articles/NSGEV_Val.html">TVGEV: Checks</a>
    </li>
    <li>
      <a href="../articles/NSRL.html">TVGEV: Check Return Levels</a>
    </li>
    <li>
      <a href="../articles/ProfLik.html">TVGEV: Check Profile Likelihood</a>
    </li>
    <li>
      <a href="../articles/simulatedBreaks.html">TVGEV: Check Simulated Trend</a>
    </li>
    <li>
      <a href="../articles/Venice.html">TVGEV: Check Venice Example</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/IRSN/NSGEV/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Time-Varying Models in NSGEV</h1>
                        <h4 data-toc-skip class="author">Yves
Deville</h4>
            
            <h4 data-toc-skip class="date">2024-12-02</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/IRSN/NSGEV/blob/main/vignettes/IntroTVGEV.Rmd" class="external-link"><code>vignettes/IntroTVGEV.Rmd</code></a></small>
      <div class="hidden name"><code>IntroTVGEV.Rmd</code></div>

    </div>

    
    
<p>This document was created with <strong>NSGEV</strong> 0.2.0.</p>
<div class="section level2">
<h2 id="scope">Scope<a class="anchor" aria-label="anchor" href="#scope"></a>
</h2>
<p>The <strong>NSGEV</strong> package provides a class of R objects
representing models for observations following a Time-Varying
Generalized Extreme Value (GEV) distribution, usually block maxima, as
described in the chapter 6 of the book by Coles <span class="citation">(Coles 2001)</span>. This class of models is named
<code>"TVGEV"</code>. These models are specific Non-Stationary GEV
models: <em>only slowly varying functions of the time can be used as
covariates</em>. They can be fitted by using CRAN packages such as
<strong>ismev</strong> <span class="citation">(<strong>Rpack_ismev?</strong>)</span>,
<strong>evd</strong> <span class="citation">(Stephenson 2002)</span>,
<strong>extRemes</strong> <span class="citation">(Gilleland and Katz
2016)</span> and more. However with these packages, the particularities
of the Time-Varying context are not taken into account, and it is quite
difficult for instance to compute predictions. The <code>TVGEV</code>
class and its methods have the following features.</p>
<ul>
<li><p>Return levels are easily computed for a given time.</p></li>
<li><p>The inference on return levels can be obtained by
profile-likelihood, using a dedicated algorithm.</p></li>
<li><p>The return level specific to the time-varying framework of Parey
et al <span class="citation">(Parey, Sylvie and Hoang, Thi Thu Huong and
Dacunha-Castelle, Didier 2010)</span> can be computed as well as
profile-likelihood confidence intervals on it.</p></li>
<li><p>Graphical diagnostics favour the <strong>ggplot</strong> system
<span class="citation">(Wickham 2016)</span>. The <code>autoplot</code>
and <code>autolayer</code> S3 methods are consequently used instead of
the <code>plot</code> and <code>lines</code> S3 methods of the classical
<strong>graphics</strong> package.</p></li>
</ul>
<p>The present vignette shows how models can be specified and fitted,
and illustrates the use of the principal methods.</p>
</div>
<div class="section level2">
<h2 id="a-simple-linear-trend-on-the-gev-location">A simple linear trend on the GEV location<a class="anchor" aria-label="anchor" href="#a-simple-linear-trend-on-the-gev-location"></a>
</h2>
<div class="section level3">
<h3 id="data-for-illustration">Data for illustration<a class="anchor" aria-label="anchor" href="#data-for-illustration"></a>
</h3>
<p>We begin by using the dataset <code>TXMax_Dijon</code> shipped with
the package.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">TXMax_Dijon</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   Year TXMax</span></span>
<span><span class="co">## 1 1921    NA</span></span>
<span><span class="co">## 2 1922    NA</span></span>
<span><span class="co">## 3 1923    NA</span></span>
<span><span class="co">## 4 1924  33.6</span></span>
<span><span class="co">## 5 1925  34.2</span></span>
<span><span class="co">## 6 1926  34.8</span></span></code></pre>
<p>The data represent the annual maxima of the daily maximal temperature
(<code>TX</code>) in Dijon (France). The time series is shown on the
next plot (R code not shown). The data are provided by <a href="https://www.ecad.eu" class="external-link">European Climate Assessment and
Dataset</a>.</p>
<p><img src="Rgraphics%2FDijon0b-1.png" width="576"></p>
<p>The observations from 1980 on seem to be larger than that of the
beginning of the series, motivating the use of a time-varying model.</p>
</div>
<div class="section level3">
<h3 id="simple-linear-trend">Simple linear trend<a class="anchor" aria-label="anchor" href="#simple-linear-trend"></a>
</h3>
<p>As a possible model, a time-varying block maxima model relates the
distribution of the response
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>b</mi></msub><annotation encoding="application/x-tex">Y_b</annotation></semantics></math>
for the block (year)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
to the corresponding time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>b</mi></msub><annotation encoding="application/x-tex">t_b</annotation></semantics></math>,
assuming that the observations are independent across blocks. We will
assume here that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>b</mi></msub><annotation encoding="application/x-tex">Y_b</annotation></semantics></math>
has a GEV distribution with constant scale
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>,
a constant shape
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ξ</mi><annotation encoding="application/x-tex">\xi</annotation></semantics></math>
and a time-varying location
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>μ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>μ</mi><mn>1</mn></msub><mi>t</mi></mrow><annotation encoding="application/x-tex">\mu(t) = \mu_0 + \mu_1 t</annotation></semantics></math>.
This model involves a vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝛙</mi><mo>:=</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>μ</mi><mn>0</mn></msub><mo>,</mo><mspace width="0.167em"></mspace><msub><mi>μ</mi><mn>1</mn></msub><mo>,</mo><mspace width="0.167em"></mspace><mi>σ</mi><mo>,</mo><mspace width="0.167em"></mspace><mi>ξ</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{\psi} := [\mu_0, \,\mu_1, \, \sigma, \, \xi]</annotation></semantics></math>
of four unknown parameters.</p>
<p>We can fit this model by using several CRAN packages, for instance
the <strong>extRemes</strong> package. With this package we need to
exclude the missing values for the response</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fite1</span> <span class="op">&lt;-</span> <span class="fu">extRemes</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/extRemes/man/fevd.html" class="external-link">fevd</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">TXMax</span>,</span>
<span>                        data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/subset.html" class="external-link">subset</a></span><span class="op">(</span><span class="va">TXMax_Dijon</span>, <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">TXMax</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                        type <span class="op">=</span> <span class="st">"GEV"</span>, location.fun <span class="op">=</span> <span class="op">~</span><span class="va">Year</span><span class="op">)</span></span></code></pre></div>
<p>Note that a classical <em>formula</em> is used to specify the model
as it is done for linear models with <code>lm</code> or
<code>glm</code>. By default, a formula implies the use of a constant.
So the formula <code>~ Year</code> indeed implies the existence of the
coefficient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\mu_0</annotation></semantics></math>
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>μ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>μ</mi><mn>1</mn></msub><mi>t</mi></mrow><annotation encoding="application/x-tex">\mu(t) = \mu_0 + \mu_1 t</annotation></semantics></math>.
We could have used equivalently an explicit constant with
<code>~ 1 + Year</code>. On the contrary, a model with no constant
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>μ</mi><mn>1</mn></msub><mi>t</mi></mrow><annotation encoding="application/x-tex">\mu(t) = \mu_1 t</annotation></semantics></math>
would have been specified by using the formula <code>~ Year - 1</code>.
This convention is used by most model fitting functions requiring a
formula in the linear model fashion, and <code>TVGEV</code> will be no
exception.</p>
<p>By inspecting the content of the object or by reading the help, we
can find the estimated values of the parameters</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fite1</span><span class="op">$</span><span class="va">results</span><span class="op">$</span><span class="va">par</span></span></code></pre></div>
<pre><code><span><span class="co">##         mu0         mu1       scale       shape </span></span>
<span><span class="co">##  5.07814887  0.01414038  1.84726804 -0.19990410</span></span></code></pre>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fite1</span><span class="op">$</span><span class="va">results</span><span class="op">$</span><span class="va">value</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 180.6135</span></span></code></pre>
<p>We see that the estimated location increases by about
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>×</mo><msub><mover><mi>μ</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">100 \times
\widehat{\mu}_1 =</annotation></semantics></math> 1.41 Celsius by
century, with an intercept value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>μ</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">\widehat{\mu}_0 =</annotation></semantics></math>
5.08 Celsius corresponding to the year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>.
We extracted as well the negative maximized log-likelihood stored in the
element <code>results$value</code>.</p>
<p>To achieve nearly the same thing with the <strong>NSGEV</strong>
package, we need a little extra work: adding a column with class
<code>"Date"</code> to the data frame. Each observation of this date
column represents the beginning of a block. We can simply paste a month
and day indication <code>-mm-dd</code> to the year in order to get a
POSIX format</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/with.html" class="external-link">within</a></span><span class="op">(</span><span class="va">TXMax_Dijon</span>, <span class="va">Date</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="va">Year</span>, <span class="st">"-01-01"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">class</a></span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">Date</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "Date"</span></span></code></pre>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">Date</span>, n <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "1921-01-01" "1922-01-01" "1923-01-01" "1924-01-01" "1925-01-01"</span></span></code></pre>
<p>Note that we no longer have to remove the observations with a missing
response. Now we can fit the same model</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitNLin</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/TVGEV.html">TVGEV</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, response <span class="op">=</span> <span class="st">"TXMax"</span>, date <span class="op">=</span> <span class="st">"Date"</span>,</span>
<span>               design <span class="op">=</span> <span class="fu"><a href="../reference/polynomX.html">polynomX</a></span><span class="op">(</span>date <span class="op">=</span> <span class="va">Date</span>, degree <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>               loc <span class="op">=</span> <span class="op">~</span> <span class="va">t1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fitNLin</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##        mu_0       mu_t1     sigma_0        xi_0 </span></span>
<span><span class="co">## 32.93752186  0.01527735  1.84567285 -0.20471258</span></span></code></pre>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/logLik.html" class="external-link">logLik</a></span><span class="op">(</span><span class="va">fitNLin</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] -180.6005</span></span>
<span><span class="co">## attr(,"df")</span></span>
<span><span class="co">## [1] 4</span></span>
<span><span class="co">## attr(,"nobs")</span></span>
<span><span class="co">## [1] 87</span></span></code></pre>
<p>Note that we used a formula as before but now the covariate is a
function of the date which is computed by the design function, here
<code>polynomX</code>. The design function essentially returns a numeric
matrix, the column of which can be used as covariates. So the name of
the covariates depend on the design function used. This will be further
explained later.</p>
<p>The estimated parameters are nearly the same as before, except for
the first one - due to a different origin taken for the linear trend.
Indeed, the time origin for R Dates is <code>"1970-01-01"</code>. The
maximized log-likelihood is extracted by using the <code>logLik</code>
method which works for many classes of fitted models.</p>
<p>The “fitted model” object has class <code>"TVGEV"</code>, and a
number of classical S3 methods with simple interpretation are
implemented</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">class</a></span><span class="op">(</span><span class="va">fitNLin</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "TVGEV"</span></span></code></pre>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/methods.html" class="external-link">methods</a></span><span class="op">(</span>class <span class="op">=</span> <span class="st">"TVGEV"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] anova         autoplot      bs            cdf           cdfMaxFun    </span></span>
<span><span class="co">##  [6] coef          confint       density       logLik        mean         </span></span>
<span><span class="co">## [11] modelMatrices moment        plot          predict       print        </span></span>
<span><span class="co">## [16] profLik       psi2theta     quantile      quantMax      quantMaxFun  </span></span>
<span><span class="co">## [21] residuals     simulate      summary       vcov         </span></span>
<span><span class="co">## see '?methods' for accessing help and source code</span></span></code></pre>
<p>For example we can use the classical <code>confint</code> method to
display confidence intervals on the parameters</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/confint.html" class="external-link">confint</a></span><span class="op">(</span><span class="va">fitNLin</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## , , 95%</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##               L       U</span></span>
<span><span class="co">## mu_0    32.5048 33.3702</span></span>
<span><span class="co">## mu_t1   -0.0005  0.0310</span></span>
<span><span class="co">## sigma_0  1.5412  2.1502</span></span>
<span><span class="co">## xi_0    -0.3489 -0.0605</span></span></code></pre>
<p>The results (by default based on the delta method) show that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
is within the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>95</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">95\%</annotation></semantics></math>
interval on the slope
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\mu_1</annotation></semantics></math>,
though being very close to the lower bound. The confidence interval on
the shape
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ξ</mi><annotation encoding="application/x-tex">\xi</annotation></semantics></math>
suggest that this parameter is negative.</p>
<p>As is generally the case with the S3 class/methods system for R,
<em>the methods should be used by invoking the generic function</em>,
e.g. <code>confint</code>. However the help for the methods can be found
by using the “dotted” name such as <code><a href="../reference/confint.TVGEV.html">?confint.TVGEV</a></code>. A method
implemented for a specific class usually has specific arguments that are
not found in the generic. For instance, the <code>confint</code> method
for the class <code>"TVGEV"</code> has a specific <code>method</code>
argument that allows choosing the inference method, with the three
choices <code>"delta"</code> (default), <code>"boot"</code> and
<code>"proflik"</code>.</p>
</div>
<div class="section level3">
<h3 id="stationary-model-with-no-trend">Stationary model with no trend<a class="anchor" aria-label="anchor" href="#stationary-model-with-no-trend"></a>
</h3>
<p>Quite obviously, we can fit a model with a constant trend by using
the relevant formula</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitNConst</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/TVGEV.html">TVGEV</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, response <span class="op">=</span> <span class="st">"TXMax"</span>, date <span class="op">=</span> <span class="st">"Date"</span>,</span>
<span>                   design <span class="op">=</span> <span class="fu"><a href="../reference/polynomX.html">polynomX</a></span><span class="op">(</span>date <span class="op">=</span> <span class="va">Date</span>, degree <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>                   loc <span class="op">=</span> <span class="op">~</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fitNConst</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##     mu_0  sigma_0     xi_0 </span></span>
<span><span class="co">## 32.94616  1.87935 -0.19645</span></span></code></pre>
<p>Since the design function is not used when the three GEV parameters
are constant, we can use <code>TVGEV</code> without its
<code>design</code> argument.</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitNConst</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/TVGEV.html">TVGEV</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, response <span class="op">=</span> <span class="st">"TXMax"</span>, date <span class="op">=</span> <span class="st">"Date"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fitNConst</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##     mu_0  sigma_0     xi_0 </span></span>
<span><span class="co">## 32.94616  1.87935 -0.19645</span></span></code></pre>
<p>Note however that we still require that the response <em>and the
date</em> are provided as columns of a data frame.</p>
<p>As a general rule, a time-varying model should always be compared to
a simpler model with three constant GEV parameters. For that aim, we can
perform a likelihood-ratio test, which is by convention attached to the
<code>anova</code> method in R.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/anova.html" class="external-link">anova</a></span><span class="op">(</span><span class="va">fitNConst</span>, <span class="va">fitNLin</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Analysis of Deviance Table</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##           df deviance      W  Pr(&gt;W)  </span></span>
<span><span class="co">## fitNConst  3   364.74                 </span></span>
<span><span class="co">## fitNLin    4   361.20 3.5412 0.05986 .</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span></code></pre>
<p>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value
is &gt; 0.05, so if we assume that there could be a global linear trend
on the location, we would accept the null hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><msub><mi>μ</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H_0: \mu_1 = 0</annotation></semantics></math>
at the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">5\%</annotation></semantics></math>
level.</p>
<p>We can investigate different forms of trend, using different
designs.</p>
</div>
</div>
<div class="section level2">
<h2 id="designs-and-models">Designs and models<a class="anchor" aria-label="anchor" href="#designs-and-models"></a>
</h2>
<div class="section level3">
<h3 id="example-polynomial-design">Example: polynomial design<a class="anchor" aria-label="anchor" href="#example-polynomial-design"></a>
</h3>
<p>Now let us have a look at the design function <code>polynomX</code>
which was used before. We can call it using the date column of the data
frame <code>df</code> passed to the formal argument <code>date</code> of
the function.</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomX.html">polynomX</a></span><span class="op">(</span>date <span class="op">=</span> <span class="va">df</span><span class="op">$</span><span class="va">Date</span>, degree <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">class</a></span><span class="op">(</span><span class="va">X</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "bts"    "matrix"</span></span></code></pre>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">X</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Block time series</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## o First block: 1921-01-01</span></span>
<span><span class="co">## o Last block:  2016-01-01</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##       date       Cst        t1 </span></span>
<span><span class="co">## 1921-01-01   1.00000 -48.99932 </span></span>
<span><span class="co">## 1922-01-01   1.00000 -48.00000 </span></span>
<span><span class="co">## 1923-01-01   1.00000 -47.00068 </span></span>
<span><span class="co">## 1924-01-01   1.00000 -46.00137 </span></span>
<span><span class="co">## 1925-01-01   1.00000 -44.99932 </span></span>
<span><span class="co">## 1926-01-01   1.00000 -44.00000</span></span></code></pre>
<p>The result is an object with class <code>"bts"</code>, inheriting
from the class <code>"matrix"</code>, with two columns. We guess that
the column named <code>Cst</code> is a column of ones as commonly used
in linear regression, and that the column <code>t1</code> is a linear
trend in years with its origin set 49 years after 1921-01-01, so near
1970-01-01. Note that a <code>TVGEV</code> model does not need to use
all the basis functions of the design: we did not use the constant
<code>Cst</code>, because a constant basis function is generated by
default when the formula is parsed.</p>
<p>The class <code>"bts"</code> describes objects representing block
times series. It is quite similar to the <code>"mts"</code> class of the
<strong>forecast</strong> package. A few methods are implemented for
this class e.g. the <code>autoplot</code> method. To illustrate this
method, we consider a different design function involving broken line
splines, namely the function <code>breaksX</code></p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/breaksX.html">breaksX</a></span><span class="op">(</span>date <span class="op">=</span> <span class="va">df</span><span class="op">$</span><span class="va">Date</span>, breaks <span class="op">=</span> <span class="st">"1970-01-01"</span>, degree <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="va">X</span>, facets <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2FDesign0b-1.png" width="576"></p>
<p>The basis functions are now splines with degree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>.
The first function named <code>t1</code> is a linear function and for
each “break” date given in <code>breaks</code>, a broken line function
is added to the basis.</p>
<p>There are other design functions. These are consistently used in
<code>TVGEV</code> as follows.</p>
</div>
<div class="section level3">
<h3 id="using-designs-with-tvgev">Using designs with <code>TVGEV</code><a class="anchor" aria-label="anchor" href="#using-designs-with-tvgev"></a>
</h3>
<p>With <code>TVGEV</code></p>
<ul>
<li><p>When the model is fitted, the data frame specified with the
<code>data</code> formal argument <em>must contain a column giving the
date of the beginning of each block</em>. The column name is specified
by using the <code>date</code> formal argument of
<code>TVGEV</code>.</p></li>
<li><p>The date column is <em>passed to a design function</em> given in
the <code>design</code> formal argument. The value of
<code>design</code> is a call to the chosen function, using the chosen
column of <code>data</code> as the <code>date</code> of the design
function.</p></li>
<li><p>The block maxima model is specified through <em>formulas linking
the GEV parameters to the columns of the design matrix</em>.</p></li>
<li><p>The fitted model object keeps track of the design function used
and therefore can use it on a “new” period of time to make a
prediction.</p></li>
</ul>
<p><img src="images%2FDesignC.png" width="80%"></p>
</div>
<div class="section level3">
<h3 id="broken-line-trend-on-the-location">Broken line trend on the location<a class="anchor" aria-label="anchor" href="#broken-line-trend-on-the-location"></a>
</h3>
<p>We can use the <code>breaksX</code> design function to specify a
continuous broken line form for the location
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu(t)</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitNBreak</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/TVGEV.html">TVGEV</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, response <span class="op">=</span> <span class="st">"TXMax"</span>, date <span class="op">=</span> <span class="st">"Date"</span>,</span>
<span>               design <span class="op">=</span> <span class="fu"><a href="../reference/breaksX.html">breaksX</a></span><span class="op">(</span>date <span class="op">=</span> <span class="va">Date</span>, breaks <span class="op">=</span> <span class="st">"1970-01-01"</span>, degree <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>               loc <span class="op">=</span> <span class="op">~</span> <span class="va">t1</span> <span class="op">+</span> <span class="va">t1_1970</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fitNBreak</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##        mu_0       mu_t1  mu_t1_1970     sigma_0        xi_0 </span></span>
<span><span class="co">## 32.06638460 -0.02392656  0.07728411  1.75541862 -0.18112018</span></span></code></pre>
<p>The location parameter now involves three parameters according to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>μ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>μ</mi><mn>1</mn></msub><mi>t</mi><mo>+</mo><msub><mi>μ</mi><mn>2</mn></msub><msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>t</mi><mo>−</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">
\mu(t) = \mu_0 + \mu_1 t + \mu_2  [t - t_0]_+
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mo>+</mo></msub><mo>:=</mo><mo>max</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mspace width="0.167em"></mspace><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x_+ := \max(0,\, x)</annotation></semantics></math>
is the “positive part” function and where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>
corresponds to the break point in time. Note that the slope of the
location
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu(t)</annotation></semantics></math>
is given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\mu_0</annotation></semantics></math>
before the break point, and by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>μ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mu_0 + \mu_1</annotation></semantics></math>
after that point. This corresponds to the two estimated slopes in
Celsius by century:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>×</mo><msub><mover><mi>μ</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">100 \times \widehat{\mu}_1 =</annotation></semantics></math>
-2.4 (before break) and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mover><mi>μ</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo>+</mo><msub><mover><mi>μ</mi><mo accent="true">̂</mo></mover><mn>2</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">100
\times [\widehat{\mu}_1 + \widehat{\mu}_2] =</annotation></semantics></math>
5.3 (after). Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">\mu_2</annotation></semantics></math>
represents the change of slope, we could decide whether the change of
slope is significant or not by querying whether a confidence interval on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">\mu_2</annotation></semantics></math>
contains
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
or not. Another solution based on <code>anova</code> is described
later.</p>
<p>To assess the change in the distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>b</mi></msub><annotation encoding="application/x-tex">Y_b</annotation></semantics></math>,
many graphical diagnostics can be produced with <strong>NSGEV</strong>.
For instance we can use the <code>quantile</code> method, which produces
a <code>bts</code> block time-series that can be autoplotted</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/quantile.html" class="external-link">quantile</a></span><span class="op">(</span><span class="va">fitNBreak</span>, prob <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.95</span>, <span class="fl">0.99</span>, <span class="fl">1.00</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2FfitNBreak-2-1.png" width="576"></p>
<p>Since the estimated value of the shape parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ξ</mi><annotation encoding="application/x-tex">\xi</annotation></semantics></math>
is negative, all the GEV distributions for the observations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>b</mi></msub><annotation encoding="application/x-tex">Y_b</annotation></semantics></math>
are estimated as having a finite upper end-point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>:=</mo><mi>μ</mi><mo>−</mo><mi>σ</mi><mi>/</mi><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\omega := \mu - \sigma / \xi</annotation></semantics></math>.
We can find this value by setting the probability to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1.0</mn><annotation encoding="application/x-tex">1.0</annotation></semantics></math>
in the quantile function. Remind that we use the <em>estimated</em>
distribution, so the shown upper end-point is the estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>ω</mi><mo accent="true">̂</mo></mover><mi>b</mi></msub><annotation encoding="application/x-tex">\widehat{\omega}_b</annotation></semantics></math>.
We could infer on the unknown value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mi>b</mi></msub><annotation encoding="application/x-tex">\omega_b</annotation></semantics></math>
by using confidence intervals. The value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mi>b</mi></msub><annotation encoding="application/x-tex">\omega_b</annotation></semantics></math>
is the return level (conditional on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>b</mi></msub><annotation encoding="application/x-tex">t_b</annotation></semantics></math>)
corresponding to an infinite return period
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">T=\infty</annotation></semantics></math>.</p>
<p>The two models corresponding to the objects <code>fitNLin</code> and
<code>fitNBreak</code> are <em>nested</em>: by setting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mu_2 = 0</annotation></semantics></math>
in the second model, we retrieve the first one. So we can perform a
likelihood-ratio test as above.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/anova.html" class="external-link">anova</a></span><span class="op">(</span><span class="va">fitNLin</span>, <span class="va">fitNBreak</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Analysis of Deviance Table</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##           df deviance      W   Pr(&gt;W)   </span></span>
<span><span class="co">## fitNLin    4    361.2                   </span></span>
<span><span class="co">## fitNBreak  5    354.4 6.7982 0.009125 **</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span></code></pre>
<p>We see from the very small
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value
labelled <code>Pr(&gt;W)</code> that the null hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mu_2 = 0</annotation></semantics></math>
must be rejected in favour of a break at the chosen break time as
defended by <code>fitNBreak</code>.</p>
<p>A limitation of the <code>fitNBreak</code> model is that the break
time can not be estimated simply. The same problem arises for the
Gaussian regression known as <em>kink regression</em>. So we can try
another basis of slowly varying functions which is flexible enough to
describe a smooth transition between two linear trends with different
slopes.</p>
</div>
<div class="section level3">
<h3 id="natural-spline-basis">Natural spline basis<a class="anchor" aria-label="anchor" href="#natural-spline-basis"></a>
</h3>
<p>As a third example of design, we will use the <em>natural spline</em>
design as implemented by <code>natSplineX</code>. With this design, we
need to give two boundary knots as well as a number of knots between the
boundary knots. Along with its flexibility, an interesting property of
this basis is that the extrapolation outside of the boundary knots is
“only” linear. By using polynomials of degree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>,
we would get a quadratic trend which becomes unrealistic even for a
small amount of extrapolation.</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">X1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/natSplineX.html">natSplineX</a></span><span class="op">(</span>date <span class="op">=</span> <span class="va">df</span><span class="op">$</span><span class="va">Date</span>, knots <span class="op">=</span> <span class="st">"1970-01-01"</span>,</span>
<span>                 boundaryKnots <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"1921-01-01"</span>, <span class="st">"2017-01-01"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="va">X1</span>, facets <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2FfitNNS-design-1.png" width="576"></p>
<p>The basis functions are linearly independent but they span a linear
space which contains the constant
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>;
in other words, if we add a column of ones to <code>unclass(X1)</code>
we get a matrix with four columns but with rank
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>.
So we can either use a constant and two of the basis functions, or use
the three basis function but <em>we then have to remove the default
constant</em> as follows.</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitNNS</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/TVGEV.html">TVGEV</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, response <span class="op">=</span> <span class="st">"TXMax"</span>, date <span class="op">=</span> <span class="st">"Date"</span>,</span>
<span>               design <span class="op">=</span> <span class="fu"><a href="../reference/natSplineX.html">natSplineX</a></span><span class="op">(</span>date <span class="op">=</span> <span class="va">Date</span>, knots <span class="op">=</span> <span class="st">"1970-01-01"</span>,</span>
<span>                   boundaryKnots <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"1920-01-01"</span>, <span class="st">"2017-01-01"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>               loc <span class="op">=</span> <span class="op">~</span> <span class="va">ns1</span> <span class="op">+</span> <span class="va">ns2</span> <span class="op">+</span> <span class="va">ns3</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>As before the models corresponding to <code>fitNLin</code> and
<code>fitNNS</code> are nested because the basis functions used in
<code>fitNLin</code> (the implicit constant
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
and the linear function <code>t1</code>) both are in the linear space
generated by the natural spline basis. So we can use the
<code>anova</code> method.</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/anova.html" class="external-link">anova</a></span><span class="op">(</span><span class="va">fitNLin</span>, <span class="va">fitNNS</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Analysis of Deviance Table</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##         df deviance      W  Pr(&gt;W)   </span></span>
<span><span class="co">## fitNLin  4   361.20                  </span></span>
<span><span class="co">## fitNNS   5   354.14 7.0651 0.00786 **</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span></code></pre>
<p>Again we see that <code>fitNNS</code> fits the data significantly
better than <code>fitNLin</code> does. We can not compare the two models
<code>fitNBreak</code> and <code>fitNNS</code> by using
<code>anova</code> because they are no longer nested. However since
these two models have the same number of parameters, using AIC or BIC
would conclude to a slight advantage in favour of <code>fitNNS</code>
which has a slightly smaller deviance, hence a slightly larger
log-likelihood.</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Breaks"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/AIC.html" class="external-link">BIC</a></span><span class="op">(</span><span class="va">fitNBreak</span><span class="op">)</span>, <span class="st">"Natural Spline"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/AIC.html" class="external-link">BIC</a></span><span class="op">(</span><span class="va">fitNNS</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##         Breaks Natural Spline </span></span>
<span><span class="co">##       376.7323       376.4654</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="possible-numerical-problems">Possible numerical problems<a class="anchor" aria-label="anchor" href="#possible-numerical-problems"></a>
</h3>
<p>A possible source of problems, the design matrices created by the
design functions can take large values. Indeed, a date is considered as
a number of days for a given origin; for a long series we will get basis
functions with values of several thousands or even much more when
polynomials with degree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">&gt;1</annotation></semantics></math>
are used. In order to facilitate the task of maximizing the likelihood,
it is worth using the <code>origin</code> formal argument of the
provided design functions, setting it to a date close to the mean date
of the series.</p>
</div>
</div>
<div class="section level2">
<h2 id="return-levels-and-quantiles">Return levels and quantiles<a class="anchor" aria-label="anchor" href="#return-levels-and-quantiles"></a>
</h2>
<div class="section level3">
<h3 id="conditional-return-levels">Conditional return levels<a class="anchor" aria-label="anchor" href="#conditional-return-levels"></a>
</h3>
<p>With time-varying models or non-stationary models, the concept of
return level becomes quite messy, because many reasonable definitions
can be given. The simplest return levels are the <em>conditional</em>
ones, obtained by fixing a time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and by considering the quantiles of the fitted distribution for that
specific time.</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pBreak</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fitNBreak</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Since 'object' is really time-varying, the Return Levels</span></span>
<span><span class="co">## depend on the date. A default choice of dates is made here.</span></span>
<span><span class="co">## Use the 'newdate' formal to change this.</span></span></code></pre>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="va">pBreak</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2FfitNBreakpredict-1.png" width="576"></p>
<p>As suggested by the warning message, three “round” values are chosen
by default for the time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and the return level plots are shown for each of these in a specific
facet of the plot. Note that the axis could have used a probability of
exceedance on a yearly basis rather than a period in years. We can make
a different choice by using the <code>newdate</code> optional argument
of <code>predict</code>, see <code><a href="../reference/predict.TVGEV.html">?predict.TVGEV</a></code>.</p>
</div>
<div class="section level3">
<h3 id="confidence-intervals">Confidence Intervals<a class="anchor" aria-label="anchor" href="#confidence-intervals"></a>
</h3>
<p>Each of the return levels is computed with a confidence interval with
its default level set to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.95</mn><annotation encoding="application/x-tex">0.95</annotation></semantics></math>.
By default, the delta method is used, resulting in symmetrical
confidence intervals. Two alternative methods can be used by setting the
optional argument <code>confintMethod</code>: profile-likelihood and
bootstrap. With the profile-likelihood method, a constrained
optimization method is repeatedly used and convergence diagnostics are
printed by default. To save space we remove these by setting the
<code>trace</code> argument.</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pBreakPL</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fitNBreak</span>, confintMethod <span class="op">=</span> <span class="st">"proflik"</span>, trace <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Since 'object' is really time-varying, the Return Levels</span></span>
<span><span class="co">## depend on the date. A default choice of dates is made here.</span></span>
<span><span class="co">## Use the 'newdate' formal to change this.</span></span></code></pre>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">pBreakPL</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in plot.predict.TVGEV(pBreakPL): Inasmuch the plot is actually a</span></span>
<span><span class="co">## 'ggplot', it is better to use the 'autoplot' method for consistency</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="unconditional-return-levels">Unconditional return levels<a class="anchor" aria-label="anchor" href="#unconditional-return-levels"></a>
</h3>
<p><em>Unconditional return levels</em> can be defined for the
time-varying framework. These are obtained by aggregating several times
corresponding to a prediction period. Many definitions are possible; a
natural requirement is that the usual definition continues to hold when
a stationary model is considered as time-varying.</p>
<p>Following Parey et al <span class="citation">(Parey, Sylvie and
Hoang, Thi Thu Huong and Dacunha-Castelle, Didier 2010)</span>, we can
define the return level corresponding to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
years as the level
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>
such that the number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
of exceedances over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>
in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
“next years” has unit expectation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mathbb{E}(N) = 1</annotation></semantics></math>.
The notion of “next” year is relative to a time origin that can be
chosen.</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pUCBreak</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/predictUncond.html">predictUncond</a></span><span class="op">(</span><span class="va">fitNBreak</span>, newdateFrom <span class="op">=</span> <span class="st">"2020-01-01"</span>,</span>
<span>                          confintMethod <span class="op">=</span> <span class="st">"proflik"</span>, trace <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">pUCBreak</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in plot.predict.TVGEV(pUCBreak): Inasmuch the plot is actually a</span></span>
<span><span class="co">## 'ggplot', it is better to use the 'autoplot' method for consistency</span></span></code></pre>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">kable</span><span class="op">(</span><span class="va">pUCBreak</span>, digits <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="left">Date</th>
<th align="right">Period</th>
<th align="left">Level</th>
<th align="right">Quant</th>
<th align="right">L</th>
<th align="right">U</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">2020-01-01</td>
<td align="right">5</td>
<td align="left">95%</td>
<td align="right">37.15</td>
<td align="right">35.97</td>
<td align="right">38.38</td>
</tr>
<tr class="even">
<td align="left">2020-01-01</td>
<td align="right">10</td>
<td align="left">95%</td>
<td align="right">38.23</td>
<td align="right">36.95</td>
<td align="right">39.62</td>
</tr>
<tr class="odd">
<td align="left">2020-01-01</td>
<td align="right">20</td>
<td align="left">95%</td>
<td align="right">39.31</td>
<td align="right">37.82</td>
<td align="right">41.00</td>
</tr>
<tr class="even">
<td align="left">2020-01-01</td>
<td align="right">30</td>
<td align="left">95%</td>
<td align="right">40.04</td>
<td align="right">38.33</td>
<td align="right">42.01</td>
</tr>
<tr class="odd">
<td align="left">2020-01-01</td>
<td align="right">40</td>
<td align="left">95%</td>
<td align="right">40.65</td>
<td align="right">38.71</td>
<td align="right">42.89</td>
</tr>
<tr class="even">
<td align="left">2020-01-01</td>
<td align="right">50</td>
<td align="left">95%</td>
<td align="right">41.22</td>
<td align="right">39.03</td>
<td align="right">43.72</td>
</tr>
<tr class="odd">
<td align="left">2020-01-01</td>
<td align="right">70</td>
<td align="left">95%</td>
<td align="right">42.30</td>
<td align="right">39.57</td>
<td align="right">45.36</td>
</tr>
<tr class="even">
<td align="left">2020-01-01</td>
<td align="right">100</td>
<td align="left">95%</td>
<td align="right">43.90</td>
<td align="right">40.29</td>
<td align="right">47.85</td>
</tr>
</tbody>
</table>
<p>For instance the return level corresponding to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">T=30</annotation></semantics></math>
years for the origin <code>"2020-01-01"</code> should be exceeded once
(on average) during the 30 years 2021 to 2050. This level is estimated
here to be 40.04 Celsius.</p>
<p>Note that an alternative definition of the return level can be
implemented as a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛙</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\rho(\boldsymbol{\psi})</annotation></semantics></math>
of the parameter vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛙</mi><annotation encoding="application/x-tex">\boldsymbol{\psi}</annotation></semantics></math>
of the model. Under quite general conditions, such a return level can be
regarded as a parameter of the model in a re-parameterization of it,
hence we can infer on it as we do for a parameter. To achieve this in
practice, the return level must be implemented as a R function with
signature <code>function(object, psi)</code> where <code>object</code>
has class <code>"TVGEV"</code> and <code>psi</code> stands for the
parameter vector. The <code>profLik</code> method can then be used to
infer on the return level using the profile-likelihood method, see
<code><a href="../reference/profLik.TVGEV.html">?profLik.TVGEV</a></code>. This method can work for any smooth
function having the previous signature.</p>
</div>
<div class="section level3">
<h3 id="quantiles-of-the-maximum">Quantiles of the maximum<a class="anchor" aria-label="anchor" href="#quantiles-of-the-maximum"></a>
</h3>
<p>Rather than trying to generalize the definition of a return level to
the time-varying framework, one can simply consider the random maximum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo>⋆</mo></msup><mo>:=</mo><msub><mo>max</mo><mi>b</mi></msub><msub><mi>Y</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">M^\star := \max_{b} Y_{b}</annotation></semantics></math>
where the maximum is over a set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ℬ</mi><mo>⋆</mo></msup><annotation encoding="application/x-tex">\mathcal{B}^\star</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mo>⋆</mo></msup><annotation encoding="application/x-tex">n^\star</annotation></semantics></math>
blocks. The most common case is when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ℬ</mi><mo>⋆</mo></msup><annotation encoding="application/x-tex">\mathcal{B}^\star</annotation></semantics></math>
is a future period
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><msubsup><mi>b</mi><mn>0</mn><mo>⋆</mo></msubsup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b = b_0^\star + 1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\dots</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>b</mi><mn>0</mn><mo>⋆</mo></msubsup><mo>+</mo><msup><mi>n</mi><mo>⋆</mo></msup></mrow><annotation encoding="application/x-tex">b_0^\star + n^\star</annotation></semantics></math>,
such as the lifetime or <em>design life</em> <span class="citation">(Rootzén and Katz 2013)</span> of an equipment, and one
want to assess a risk related to the possible exceedance over some high
level during this period. Since the blocks are assumed to be independent
we have</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><msup><mi>M</mi><mo>⋆</mo></msup></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>m</mi><mo>⋆</mo></msup><mo>;</mo><mspace width="0.167em"></mspace><mi>𝛙</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>∏</mo><mrow><mi>b</mi><mo>∈</mo><msup><mi>ℬ</mi><mo>⋆</mo></msup></mrow></munder><msub><mi>F</mi><mtext mathvariant="monospace">𝙶𝙴𝚅</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>m</mi><mo>⋆</mo></msup><mo>;</mo><mspace width="0.167em"></mspace><msub><mi>𝛉</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="2.0em"></mspace><mrow><mtext mathvariant="normal">for all </mtext><mspace width="0.333em"></mspace></mrow><msup><mi>m</mi><mo>⋆</mo></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
   F_{M^\star}(m^\star;\,\boldsymbol{\psi}) 
   = \prod_{b \in \mathcal{B}^\star} 
    F_{\texttt{GEV}}(m^\star;\,\boldsymbol{\theta}_{b}) \qquad \text{for all }
    m^\star,
</annotation></semantics></math></p>
<p>where the dependence on the parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛙</mi><annotation encoding="application/x-tex">\boldsymbol{\psi}</annotation></semantics></math>
is through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝛉</mi><mi>b</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛙</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{\theta}_b(\boldsymbol{\psi})</annotation></semantics></math>.
Note that in general
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>M</mi><mo>⋆</mo></msup><annotation encoding="application/x-tex">M^\star</annotation></semantics></math>
does not follow a GEV distribution.</p>
<p>The corresponding quantile function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><msup><mi>M</mi><mo>⋆</mo></msup></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">q_{M^\star}(p)</annotation></semantics></math>
can be computed numerically either by solving
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><msup><mi>M</mi><mo>⋆</mo></msup></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>q</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">F_{M^\star}(q) = p</annotation></semantics></math>
or by interpolating from couples of values <em>probability</em>,
<em>quantile</em>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>p</mi><mi>i</mi></msub><mo>,</mo><mspace width="0.167em"></mspace><msub><mi>q</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[p_i,\,q_i]</annotation></semantics></math>.
For a given probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>,
the derivative of the corresponding quantile w.r.t.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛙</mi><annotation encoding="application/x-tex">\boldsymbol{\psi}</annotation></semantics></math>
can be obtained by the implicit function theorem and can be used to
infer on the quantile.</p>
<p>In <strong>NSGEV</strong>, the <code>quantMax</code> method can be
used to produce a table of values for the quantile function from a
<code>TVGEV</code> object. Such a table is given the S3 class
<code>"quantMax.TVGEV"</code> for which an <code>autoplot</code> method
has been implemented</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">newDate</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html" class="external-link">sprintf</a></span><span class="op">(</span><span class="st">"%4d-01-01"</span>, <span class="fl">2025</span><span class="op">:</span><span class="fl">2054</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">qM</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/quantMax.html">quantMax</a></span><span class="op">(</span><span class="va">fitNBreak</span>, date <span class="op">=</span> <span class="va">newDate</span>, level <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.70</span>, <span class="fl">0.95</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">gqM</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="va">qM</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">ggtitle</a></span><span class="op">(</span><span class="st">"Maximum on years 2025-2054 with delta confidence intervals"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">gqM</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2FquantMax1-1.png" width="576"></p>
<p>The plot shows the quantile
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><msup><mi>M</mi><mo>⋆</mo></msup></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">q_{M^\star}(p)</annotation></semantics></math>
against the probability of exceedance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">1 -p</annotation></semantics></math>
using a Gumbel scale. So if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>M</mi><mo>⋆</mo></msup><annotation encoding="application/x-tex">M^\star</annotation></semantics></math>
happens to be Gumbel (as can happen in the stationary case) the quantile
line will be a straight line. When the period of interest
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ℬ</mi><mo>⋆</mo></msup><annotation encoding="application/x-tex">\mathcal{B}^\star</annotation></semantics></math>
is increased the maximum becomes stochastically larger. For instance,
with a fixed beginning if the duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mo>⋆</mo></msup><annotation encoding="application/x-tex">n^\star</annotation></semantics></math>
of the period is increased the maximum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>M</mi><mo>⋆</mo></msup><annotation encoding="application/x-tex">M^\star</annotation></semantics></math>
becomes stochastically larger: all quantiles are increased.</p>
<p>It is worth noting that as far as a small probability of exceedance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>p</mi><mo accent="true">‾</mo></mover><mo>:=</mo><mn>1</mn><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\bar{p} := 1 -p</annotation></semantics></math>
is concerned, the expected value of the random number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
of exceedances over the corresponding quantile is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>N</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>≈</mo><mover><mi>p</mi><mo accent="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\mathbb{E}[N] \approx \bar{p}</annotation></semantics></math>.
This approximation is acceptable when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>p</mi><mo accent="true">‾</mo></mover><mo>&lt;</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">\bar{p} &lt; 0.05</annotation></semantics></math>.</p>
<p>On the previous plot, confidence intervals based on the delta method
are shown. It is now possible to use profile likelihood intervals, at
the price of an increased computation time.</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">qM2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/quantMax.html">quantMax</a></span><span class="op">(</span><span class="va">fitNBreak</span>, date <span class="op">=</span> <span class="va">newDate</span>, level <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.70</span>, <span class="fl">0.95</span><span class="op">)</span>,</span>
<span>                confint <span class="op">=</span> <span class="st">"proflik"</span><span class="op">)</span></span>
<span><span class="va">gqM2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="va">qM2</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">ggtitle</a></span><span class="op">(</span><span class="st">"Maximum on years 2025-2054 with profile likelihood  intervals"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">gqM2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2FquantMax2-1.png" width="576"></p>
<p>Needless to say, for a small probability of exceedance, the upper
bound of the profile likelihood
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>95</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">95\%</annotation></semantics></math>
confidence interval is much larger than that of the delta interval.</p>
</div>
</div>
<div class="section level2">
<h2 id="simulate-from-a-fitted-model">Simulate from a fitted model<a class="anchor" aria-label="anchor" href="#simulate-from-a-fitted-model"></a>
</h2>
<p>The <code>simulate</code> method is implemented in many R packages,
with the aim to simulate new data from a given model. It has been
implemented for the <code>TVGEV</code> class. A fitted model object can
be used to simulate new paths either for the fitting time period or for
a new one.</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">fitNBreak</span>, nsim <span class="op">=</span> <span class="fl">100</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2Fsimulate1-1.png" width="576"></p>
<p>We can use a different period to better understand how the model
anticipates new data</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="st">"2020-01-01"</span><span class="op">)</span>, length <span class="op">=</span> <span class="fl">10</span>, by <span class="op">=</span> <span class="st">"years"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">fitNBreak</span>, nsim <span class="op">=</span> <span class="fl">10</span>, newdate <span class="op">=</span> <span class="va">nd</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2Fsimulate2-1.png" width="576"></p>
<p>The simulated paths are here drawn in colour with a legend because
their number is small enough. Note that <code>simulate</code> is
functionally close to a prediction: the mean of a large number of
simulated paths is close to the expectation used in a prediction and the
uncertainty on the prediction can be assessed by using the dispersion of
the simulated paths.</p>
</div>
<div class="section level2">
<h2 id="more-diagnostics-and-results">More diagnostics and results<a class="anchor" aria-label="anchor" href="#more-diagnostics-and-results"></a>
</h2>
<div class="section level3">
<h3 id="residuals">Residuals<a class="anchor" aria-label="anchor" href="#residuals"></a>
</h3>
<p>The generalized residuals are random variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>b</mi></msub><annotation encoding="application/x-tex">e_b</annotation></semantics></math>
related to the observations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>b</mi></msub><annotation encoding="application/x-tex">y_b</annotation></semantics></math>,
so they form a block time-series. The distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>b</mi></msub><annotation encoding="application/x-tex">e_b</annotation></semantics></math>
should be nearly the same for all blocks
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
and the dependence between the blocks should be weak <span class="citation">(Cox and Snell 2018)</span>. Several definitions of the
residuals are possible, in relation with a target distribution. A simple
choice is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>b</mi></msub><mo>:=</mo><msub><mi>F</mi><mtext mathvariant="normal">GEV</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>b</mi></msub><mo>;</mo><mspace width="0.167em"></mspace><msub><mover><mi>𝛉</mi><mo accent="true">̂</mo></mover><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">e_b := F_{\text{GEV}}(y_b;\, \widehat{\boldsymbol{\theta}}_b)</annotation></semantics></math>
which should lead nearly to a uniform distribution on the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mspace width="0.167em"></mspace><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,\,1)</annotation></semantics></math>.
Other possible choices are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>b</mi></msub><mo>:=</mo><mo>−</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>−</mo><msub><mi>F</mi><mtext mathvariant="normal">GEV</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>b</mi></msub><mo>;</mo><mspace width="0.167em"></mspace><msub><mover><mi>𝛉</mi><mo accent="true">̂</mo></mover><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">e_b := -\log[1 -
F_{\text{GEV}}(y_b;\, \widehat{\boldsymbol{\theta}}_b)]\}</annotation></semantics></math>
for a standard exponential target as used by <span class="citation">Panagoulia, Economou, and Caroni (2014)</span> and by
<span class="citation">Katz, Parlange, and Naveau (2002)</span>, or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>b</mi></msub><mo>:=</mo><mo>log</mo><mo stretchy="false" form="prefix">{</mo><mo>−</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>−</mo><msub><mi>F</mi><mtext mathvariant="normal">GEV</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>b</mi></msub><mo>;</mo><mspace width="0.167em"></mspace><msub><mover><mi>𝛉</mi><mo accent="true">̂</mo></mover><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">e_b := \log\{-\log[1 -
F_{\text{GEV}}(y_b;\, \widehat{\boldsymbol{\theta}}_b)]\}</annotation></semantics></math>
for a standard Gumbel target. Note that the <code>resid</code> method of
the package uses an <em>increasing</em> transformation so that
large/small residuals correspond to large/small observations. When the
GEV marginal distributions have a nearly exponential tail
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi><mo>≈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\xi \approx 0</annotation></semantics></math>
using the standard Gumbel target for the generalized residuals can be
preferred because this will use a milder transformation of the data.
This is now the default choice.</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/residuals.html" class="external-link">resid</a></span><span class="op">(</span><span class="va">fitNBreak</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2Fresid-1.png" width="576"></p>
<p>The horizontal lines show an interval with approximate probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>95</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">95\%</annotation></semantics></math>.
The use of these residuals is similar to that in the usual linear
regression framework where the distribution of the standardized
residuals is close to the standard normal.</p>
</div>
<div class="section level3">
<h3 id="parameters-psi-boldsymbolpsi-vs-theta-boldsymboltheta">Parameters: “psi”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛙</mi><annotation encoding="application/x-tex">\boldsymbol{\psi}</annotation></semantics></math>
vs “theta”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛉</mi><annotation encoding="application/x-tex">\boldsymbol{\theta}</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#parameters-psi-boldsymbolpsi-vs-theta-boldsymboltheta"></a>
</h3>
<p>As shown before the parameters of the model can be extracted by using
the <code>coef</code> method. Using a non-standard terminology which
seems specific to the package, we can say that these are the “psi”
parameters. But we can be interested as well by the GEV parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>
,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ξ</mi><annotation encoding="application/x-tex">\xi</annotation></semantics></math>
that we can call “theta”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝛉</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>μ</mi><mo>,</mo><mspace width="0.167em"></mspace><mi>σ</mi><mo>,</mo><mspace width="0.167em"></mspace><mi>ξ</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{\theta}= [\mu,\, \sigma, \,\xi]</annotation></semantics></math>.
Since these parameters depend on the time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
we can consider them as forming a block time series. We can “extract”
these parameters by using the optional formal <code>type</code> of the
<code>coef</code> method; this leads to a <code>bts</code> object that
can be autoplotted. Remind that the physical dimensions of the
parameters differ -
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>
have the dimension of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>b</mi></msub><annotation encoding="application/x-tex">Y_b</annotation></semantics></math>
while
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ξ</mi><annotation encoding="application/x-tex">\xi</annotation></semantics></math>
is dimensionless - so we have better show each series in a facet with
its own
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
axis.</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">thetas</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fitNBreak</span>, type <span class="op">=</span> <span class="st">"theta"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="va">thetas</span>, facets <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2FfitNBreakthetas-1.png" width="576"></p>
</div>
<div class="section level3">
<h3 id="marginal-distributions">Marginal distributions<a class="anchor" aria-label="anchor" href="#marginal-distributions"></a>
</h3>
<p>Several methods can be used to assess the marginal distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>b</mi></msub><annotation encoding="application/x-tex">Y_b</annotation></semantics></math>
for a specific time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>b</mi></msub><annotation encoding="application/x-tex">t_b</annotation></semantics></math>
or at a collection of times given by a <code>date</code> argument. With
the default <code>date = NULL</code>, the methods <code>quantile</code>,
<code>mean</code>, <code>moments</code> for the class
<code>"TVGEV"</code> return time series objects that can be
“autoplotted” to plot the quantiles or the mean (expectation) against
the date as it was shown before. The help page with examples can be
displayed in the usual way, e.g. with <code><a href="../reference/quantile.TVGEV.html">?quantile.TVGEV</a></code>.</p>
<p>The <code>density</code> and <code>cdf</code> methods both return a
functional time series: a collection of functions depending on the date.
These can be autoplotted as well.</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/density.html" class="external-link">density</a></span><span class="op">(</span><span class="va">fitNBreak</span><span class="op">)</span>, fill <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2FfitNBreakDens-1.png" width="576"></p>
<p>If needed, the time series with class <code>"bts"</code> can be
coerced into a standard time series inheriting from <code>"ts"</code>
for which many methods have been written in different packages.</p>
</div>
</div>
<div class="section level2">
<h2 id="bootstrap">Bootstrap<a class="anchor" aria-label="anchor" href="#bootstrap"></a>
</h2>
<div class="section level3">
<h3 id="principle">Principle<a class="anchor" aria-label="anchor" href="#principle"></a>
</h3>
<p>A large number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
of response vectors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐲</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msup><annotation encoding="application/x-tex">\mathbf{y}^{[r]}</annotation></semantics></math>
are simulated or “re-sampled” corresponding to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r=1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\dots</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.
These simulated values can be stored into a matrix with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
rows and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
columns. For each vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐲</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msup><annotation encoding="application/x-tex">\mathbf{y}^{[r]}</annotation></semantics></math>,
the MLE
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>𝛙</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msup><annotation encoding="application/x-tex">{\widehat{\boldsymbol{\psi}}}^{[r]}</annotation></semantics></math>
of the “psi” parameter vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛙</mi><annotation encoding="application/x-tex">\boldsymbol{\psi}</annotation></semantics></math>
is computed. The sample quantiles of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>𝛙</mi><mo accent="true">̂</mo></mover><mi>i</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><annotation encoding="application/x-tex">{\widehat{\boldsymbol{\psi}}}_i^{[r]}</annotation></semantics></math>
can then be used to provide a confidence interval on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ψ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\psi_i</annotation></semantics></math>.</p>
<p>The <code>bs</code> method takes a <code>TVGEV</code> object as its
first argument and computes the bootstrapped “psi” parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>𝛙</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msup><annotation encoding="application/x-tex">\widehat{\boldsymbol{\psi}}^{[r]}</annotation></semantics></math>.
These bootstrapped parameters are in fact stored as the rows of the
<code>estimate</code> element of the returned list.</p>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">myBoot</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/bs.html">bs</a></span><span class="op">(</span><span class="va">fitNBreak</span><span class="op">)</span>      </span></code></pre></div>
<pre><code><span><span class="co">## Warning in MLE.TVGEV(object, y = y[, b], estim = estim, ...): convergence not</span></span>
<span><span class="co">## reached in optimisation</span></span></code></pre>
<div class="sourceCode" id="cb63"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">myBoot</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "estimate"  "negLogLik" "R"         "optim"     "type"</span></span></code></pre>
<div class="sourceCode" id="cb65"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">myBoot</span><span class="op">$</span><span class="va">estimate</span>, n <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          mu_0       mu_t1 mu_t1_1970  sigma_0       xi_0</span></span>
<span><span class="co">## [1,] 32.18540 -0.02209687 0.07976180 1.901520 -0.2294907</span></span>
<span><span class="co">## [2,] 31.72127 -0.04716687 0.09096013 1.613856 -0.1025511</span></span>
<span><span class="co">## [3,] 31.90407 -0.02768300 0.08830328 1.636649 -0.1734725</span></span></code></pre>
<p>Note that the default number of replicates <code>R</code> is very
small and has been set for a purely illustrative use. A well-accepted
choice
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">\geqslant 3000</annotation></semantics></math>.</p>
<p><img src="images%2FBootC.png" width="80%"></p>
<p>It is easy to derive from the theta parameters the corresponding
block times series of “thetas”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>𝛉</mi><mo accent="true">̂</mo></mover><mi>b</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><annotation encoding="application/x-tex">\widehat{\boldsymbol{\theta}}_b^{[r]}</annotation></semantics></math>.
Broadly speaking we have to apply the function <code>psi2theta</code> to
each line of the matrix returned as the <code>estimate</code> element of
the result.</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mu</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">myBoot</span><span class="op">$</span><span class="va">estimate</span>, MARGIN <span class="op">=</span> <span class="fl">1</span>,</span>
<span>            FUN <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">model</span><span class="op">)</span> <span class="fu"><a href="../reference/psi2theta.html">psi2theta</a></span><span class="op">(</span>psi <span class="op">=</span> <span class="va">x</span>, model <span class="op">=</span> <span class="va">model</span><span class="op">)</span><span class="op">[</span> , <span class="fl">1</span><span class="op">]</span>,</span>
<span>            model <span class="op">=</span> <span class="va">fitNBreak</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html" class="external-link">autoplot</a></span><span class="op">(</span><span class="fu"><a href="../reference/bts.html">bts</a></span><span class="op">(</span><span class="va">mu</span>, date <span class="op">=</span> <span class="va">fitNBreak</span><span class="op">$</span><span class="va">fDate</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">ggtitle</a></span><span class="op">(</span><span class="st">"bootstrapped values for mu"</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2Fboostrap1-1.png" width="576"></p>
<p>One the bootstrapped values for the “psi” parameters have been
computed, they can be used to later infer on the return periods at a
short computing cost. In that aim, a new element named <code>boot</code>
must be added to the fitted model.</p>
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitNBreak</span><span class="op">$</span><span class="va">boot</span> <span class="op">&lt;-</span> <span class="va">myBoot</span></span></code></pre></div>
<p>Note however that this is a kind of “hack”. Some care is needed to
ensure that the new <code>boot</code> element is consistent with the
right fitted model using the right data.</p>
<p>Since most modern computers use multicore processors, a parallel
computation can be used to achieve substantial saving in the computing
time. See the example in the help page of <code>boot.ts</code> to see
how this can be achieved.</p>
</div>
<div class="section level3">
<h3 id="details-how-resampling-is-performed">Details how resampling is performed<a class="anchor" aria-label="anchor" href="#details-how-resampling-is-performed"></a>
</h3>
<p>Two methods can be used to “resample”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐲</mi><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math><span class="citation">(Panagoulia, Economou, and Caroni
2014)</span></p>
<ul>
<li><p><strong>Parametric</strong>. For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r=1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\dots</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>,
the value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>y</mi><mi>b</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><annotation encoding="application/x-tex">y_b^{[r]}</annotation></semantics></math>
is drawn as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>y</mi><mi>b</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mo>∼</mo><mtext mathvariant="normal">GEV</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>𝛉</mi><mo accent="true">̂</mo></mover><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">y_b^{[r]} \sim
 \text{GEV}(\widehat{\boldsymbol{\theta}}_b)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝛉</mi><mi>b</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\theta}_b</annotation></semantics></math>
is the MLE of the vector of the three GEV parameters corresponding to
the block
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>,
which is a function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛙</mi><annotation encoding="application/x-tex">\boldsymbol{\psi}</annotation></semantics></math>.</p></li>
<li><p><strong>Non-parametric</strong>. For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r=1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\dots</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>,
the generalized residuals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>b</mi></msub><annotation encoding="application/x-tex">e_b</annotation></semantics></math>
are resampled to form a vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐞</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msup><annotation encoding="application/x-tex">\mathbf{e}^{[r]}</annotation></semantics></math>
with the wanted size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.
Each residual
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>e</mi><mi>b</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><annotation encoding="application/x-tex">e_b^{[r]}</annotation></semantics></math>
is back-transformed to a response
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>y</mi><mi>b</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mo>:=</mo><msub><mi>q</mi><mtext mathvariant="normal">GEV</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>e</mi><mi>b</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mo>;</mo><mspace width="0.167em"></mspace><msub><mover><mi>𝛉</mi><mo accent="true">̂</mo></mover><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">y_b^{[r]} := q_{\text{GEV}}(e_b^{[r]};\,
 \widehat{\boldsymbol{\theta}}_b)</annotation></semantics></math>.</p></li>
</ul>
<p>The second method is also known under the names
<em>fixed-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
resampling</em> and <em>resampling from the residuals</em>.</p>
<p>The bootstrap
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>𝛙</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">[</mo><mi>b</mi><mo stretchy="true" form="postfix">]</mo></mrow></msup><annotation encoding="application/x-tex">\widehat{\boldsymbol{\psi}}^{[b]}</annotation></semantics></math>
can also be used to infer on the return levels, either conditional or
unconditional. For example, the conditional return level
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mi>b</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\rho_b(m)</annotation></semantics></math>
corresponding the the period of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
blocks and for the given time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>b</mi></msub><annotation encoding="application/x-tex">t_b</annotation></semantics></math>
can be inferred by using the quantiles of the return periods which are
computed as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mtext mathvariant="normal">GEV</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo>;</mo><mspace width="0.167em"></mspace><msubsup><mover><mi>𝛉</mi><mo accent="true">̂</mo></mover><mi>b</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">q_{\text{GEV}}(p;
\,\widehat{\boldsymbol{\theta}}_b^{[r]})</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:=</mo><mn>1</mn><mo>−</mo><mn>1</mn><mi>/</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">p:= 1 - 1/T</annotation></semantics></math>.</p>
</div>
</div>
<div class="section level2">
<h2 id="strengths-and-limitations-of-tvgev">Strengths and limitations of <code>TVGEV</code><a class="anchor" aria-label="anchor" href="#strengths-and-limitations-of-tvgev"></a>
</h2>
<p>The <code>"TVGEV"</code> S3 class and its dedicated methods allow a
simple use of time-varying GEV models, including prediction. Some
functionality of the package such as the simulation are not found in
more classical packages, to our best knowledge. However</p>
<ol style="list-style-type: decimal">
<li><p>Only known functions of time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math>
can be used as covariates.</p></li>
<li><p>Each of GEV parameters can only depend on the time covariates
through a linear function of these.</p></li>
<li><p>The parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>
can not be share across GEV parameters.</p></li>
</ol>
<p>To illustrate 1., we can not use a binary variable indicator of a
site in order to build a regional model. To illustrate 2., the GEV
location
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>
can be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ψ</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ψ</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\psi_1 x_1(t) + \psi_2 x_2(t)</annotation></semantics></math>
but not have the form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>ψ</mi></msup></mrow><annotation encoding="application/x-tex">x(t)^\psi</annotation></semantics></math>.
To illustrate 3., we can not have both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>ψ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>ψ</mi><mn>1</mn></msub><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu(t)
  = \psi_0 + \psi_1 x(t)</annotation></semantics></math> and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>ψ</mi><mn>3</mn></msub><mi>μ</mi></mrow><annotation encoding="application/x-tex">\sigma(t) = \psi_3 \mu</annotation></semantics></math>,
because the parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ψ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\psi_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ψ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">\psi_2</annotation></semantics></math>
are then used both by the location
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>
and the scale
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>.</p>
</div>
<div class="section level2">
<h2 id="appendix">Appendix<a class="anchor" aria-label="anchor" href="#appendix"></a>
</h2>
<div class="section level3">
<h3 id="coping-with-dates">Coping with dates<a class="anchor" aria-label="anchor" href="#coping-with-dates"></a>
</h3>
<p>In practice, the time will be represented by a <em>date</em> object,
and the POSIX format <code>"yyyy-mm-dd"</code> or in R
<code>"%Y-%m-%d"</code> will be favored. The R <strong>base</strong>
package has a <code>"Date"</code> class which is used by
<strong>NSGEV</strong></p>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">myDate</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="st">"2020-01-01"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">class</a></span><span class="op">(</span><span class="va">myDate</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "Date"</span></span></code></pre>
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">myDate</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "2020-01-01"</span></span></code></pre>
<div class="sourceCode" id="cb73"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/format.html" class="external-link">format</a></span><span class="op">(</span><span class="va">myDate</span>, <span class="st">"%d %B %Y"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "01 January 2020"</span></span></code></pre>
<div class="sourceCode" id="cb75"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">myDate</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="st">"1980-01-01"</span><span class="op">)</span>, by <span class="op">=</span> <span class="st">"years"</span>, length <span class="op">=</span> <span class="fl">40</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">myDate</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">myDate</span>, <span class="va">x</span>, type <span class="op">=</span> <span class="st">"o"</span>, xlab <span class="op">=</span> <span class="st">""</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2Fdate1-1.png" width="576"></p>
<p>The <strong>lubridate</strong> package <span class="citation">(Grolemund and Wickham 2011)</span> has functions that
can help to cope with date.</p>
</div>
<div class="section level3">
<h3 id="adding-new-design-functions">Adding new design functions<a class="anchor" aria-label="anchor" href="#adding-new-design-functions"></a>
</h3>
<p>You can add new design functions. A design function:</p>
<ul>
<li><p>Must have its first argument named <code>date</code>. This
argument is intended to be passed either as an object with class
<code>"Date"</code> or as an object which will be coerced automatically
to this class by using <code>as.Date</code>. For instance, a character
vector in POSIX format should work.</p></li>
<li><p>Must return a matrix with the basis function as its columns. It
must also have an attribute named <code>"date"</code> containing the
date vector. This object should be created either by using the
<code>bts</code> function (creator for the class) or by simply giving
the class <code>c("bts", "matrix")</code> to a matrix with the suitable
attribute.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="estimating-the-break-with-a-broken-line-trend">Estimating the break with a broken line trend<a class="anchor" aria-label="anchor" href="#estimating-the-break-with-a-broken-line-trend"></a>
</h3>
<p>Let us consider again the broken line trend discussed above,
namely</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>μ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>μ</mi><mn>1</mn></msub><mi>t</mi><mo>+</mo><msub><mi>μ</mi><mn>2</mn></msub><msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>t</mi><mo>−</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
\mu(t) = \mu_0 + \mu_1 t + \mu_2  [t - t_0]_+.
</annotation></semantics></math></p>
<p>As mentioned before, the date
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>
of a change of slope can be considered as an unknown parameter, but the
model then no longer has the form for <code>TVGEV</code> objects, so it
can no longer be estimated by using directly the <code>TVGEV</code>
function. Yet we can find the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>
by maximizing the log-likelihood over a vector of candidate values:
estimating a <code>TVGEV</code> model for each value will provide the
corresponding log-likelihoods. For a given year we can create a suitable
formatted date with the <code>sprintf</code> function as follows</p>
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">yearBreaks</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1940</span>, <span class="fl">1950</span>, <span class="fl">1955</span>, <span class="fl">1960</span><span class="op">:</span><span class="fl">2000</span>, <span class="fl">2005</span>, <span class="fl">2010</span><span class="op">)</span></span>
<span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">ib</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_along</a></span><span class="op">(</span><span class="va">yearBreaks</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sprintf.html" class="external-link">sprintf</a></span><span class="op">(</span><span class="st">"%4d-01-01"</span>, <span class="va">yearBreaks</span><span class="op">[[</span><span class="va">ib</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span>    <span class="va">floc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/formula.html" class="external-link">as.formula</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html" class="external-link">sprintf</a></span><span class="op">(</span><span class="st">"~ t1 + t1_%4d"</span>, <span class="va">yearBreaks</span><span class="op">[[</span><span class="va">ib</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">res</span><span class="op">[[</span><span class="va">d</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/TVGEV.html">TVGEV</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, response <span class="op">=</span> <span class="st">"TXMax"</span>, date <span class="op">=</span> <span class="st">"Date"</span>,</span>
<span>                      design <span class="op">=</span> <span class="fu"><a href="../reference/breaksX.html">breaksX</a></span><span class="op">(</span>date <span class="op">=</span> <span class="va">Date</span>, breaks <span class="op">=</span> <span class="va">d</span>, degree <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>                      loc <span class="op">=</span> <span class="va">floc</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We now have a list <code>res</code> of
<code>length(yearBreaks)</code> objects and the log-likelihood of each
object can be extracted by using <code>logLik</code>. So we can plot the
log-likelihood against the year and find the “best” object with maximal
log-likelihood.</p>
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ll</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="va">res</span>, <span class="va">logLik</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">yearBreaks</span>, <span class="va">ll</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">21</span>, col <span class="op">=</span> <span class="st">"orangered"</span>,</span>
<span>     lwd <span class="op">=</span> <span class="fl">2</span>, bg <span class="op">=</span> <span class="st">"gold"</span>, xlab <span class="op">=</span> <span class="st">"break"</span>, ylab <span class="op">=</span> <span class="st">"log-lik"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">iMax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.min.html" class="external-link">which.max</a></span><span class="op">(</span><span class="va">ll</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="va">yearBreaks</span><span class="op">[</span><span class="va">iMax</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>h <span class="op">=</span> <span class="va">ll</span><span class="op">[</span><span class="va">iMax</span><span class="op">]</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Chisquare.html" class="external-link">qchisq</a></span><span class="op">(</span><span class="fl">0.95</span>, df <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">/</span><span class="fl">2</span><span class="op">)</span>,</span>
<span>       col <span class="op">=</span> <span class="st">"SpringGreen3"</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Rgraphics%2Fkink2-1.png" width="576"></p>
<p>Although the points show a profiled log-likelihood, the regularity
conditions that must hold in ML estimation are not fulfilled, because
the log-likelihood is not differentiable w.r.t.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>.
As a consequence, the usual level (shown as the lower horizontal line in
green here) does not provide a confidence interval on the unknown
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="constraints-on-the-parameters-fixed-parameters">Constraints on the parameters, fixed parameters<a class="anchor" aria-label="anchor" href="#constraints-on-the-parameters-fixed-parameters"></a>
</h3>
<p>As an experimental feature, inequality constraints on the parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ψ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\psi_i</annotation></semantics></math>
can be imposed. The constraints are simple “box” constraints of the form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ψ</mi><mi>i</mi><mtext mathvariant="normal">L</mtext></msubsup><mo>≤</mo><msub><mi>ψ</mi><mi>i</mi></msub><mo>≤</mo><msubsup><mi>ψ</mi><mi>i</mi><mtext mathvariant="normal">U</mtext></msubsup></mrow><annotation encoding="application/x-tex">\psi^{\text{L}}_i \leqslant \psi_i \leqslant
\psi^{\text{U}}_i</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ψ</mi><mi>i</mi><mtext mathvariant="normal">L</mtext></msubsup><annotation encoding="application/x-tex">\psi^{\text{L}}_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ψ</mi><mi>i</mi><mtext mathvariant="normal">U</mtext></msubsup><annotation encoding="application/x-tex">\psi^{\text{U}}_i</annotation></semantics></math>
are given. These constraints can only be used when the likelihood is
maximized with the <code>nloptr</code> package. If needed, they can be
given for some parameters only, letting the other bounds fixed at their
default values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ψ</mi><mi>i</mi><mtext mathvariant="normal">L</mtext></msubsup><mo>=</mo><mo>−</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">\psi^{\text{L}}_i = -\infty</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ψ</mi><mi>i</mi><mtext mathvariant="normal">U</mtext></msubsup><mo>=</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">\psi^{\text{U}}_i = \infty</annotation></semantics></math>.</p>
<p>In practice, the constraints are given by using a named vector, and
hence the names of the parameters must be known. These names can be
retrieved if needed by first using <code>estim = "none"</code>.</p>
<div class="sourceCode" id="cb78"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitNBreak2</span> <span class="op">&lt;-</span></span>
<span>    <span class="fu"><a href="../reference/TVGEV.html">TVGEV</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, response <span class="op">=</span> <span class="st">"TXMax"</span>, date <span class="op">=</span> <span class="st">"Date"</span>,</span>
<span>          design <span class="op">=</span> <span class="fu"><a href="../reference/breaksX.html">breaksX</a></span><span class="op">(</span>date <span class="op">=</span> <span class="va">Date</span>, breaks <span class="op">=</span> <span class="st">"1970-01-01"</span>, degree <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>          loc <span class="op">=</span> <span class="op">~</span> <span class="va">t1</span> <span class="op">+</span> <span class="va">t1_1970</span>,</span>
<span>          estim <span class="op">=</span> <span class="st">"nloptr"</span>,</span>
<span>          coefLower <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"xi_0"</span> <span class="op">=</span> <span class="op">-</span><span class="fl">0.15</span><span class="op">)</span>, coefUpper <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"xi_0"</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in MLE.TVGEV(object = tv, y = NULL, psi0 = psi0, estim = estim, : some</span></span>
<span><span class="co">## estimated parameters at the bounds, inference results are misleading</span></span></code></pre>
<div class="sourceCode" id="cb80"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fitNBreak2</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##        mu_0       mu_t1  mu_t1_1970     sigma_0        xi_0 </span></span>
<span><span class="co">## 32.02318423 -0.02420594  0.07812270  1.72977928 -0.15000000</span></span></code></pre>
<p>The GEV shape parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ξ</mi><annotation encoding="application/x-tex">\xi</annotation></semantics></math>
is usually taken as constant, not time-varying; inasmuch the
log-likelihood is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>∞</mi><annotation encoding="application/x-tex">\infty</annotation></semantics></math>
when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi><mo>&lt;</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\xi &lt; -1</annotation></semantics></math>,
a lower bound
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ψ</mi><mi>i</mi><mtext mathvariant="normal">L</mtext></msubsup><mo>&gt;</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\psi^{\text{L}}_i &gt; -1</annotation></semantics></math>
should normally be set. In practice, this is usually not needed because
for numerical reasons the optimization will converge to a local maximum
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi><mo>&gt;</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\xi &gt; -1</annotation></semantics></math>
and a finite log-likelihood rather than to a parameter vector with the
infinite maximal log-likelihood.</p>
<p>The constraints can be used to set a parameter to a given value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ψ</mi><mi>i</mi><mo>⋆</mo></msubsup><annotation encoding="application/x-tex">\psi_i^\star</annotation></semantics></math>
by taking
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ψ</mi><mi>i</mi><mtext mathvariant="normal">L</mtext></msubsup><mo>:=</mo><msubsup><mi>ψ</mi><mi>i</mi><mo>⋆</mo></msubsup></mrow><annotation encoding="application/x-tex">\psi^{\text{L}}_i := \psi_i^\star</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ψ</mi><mi>i</mi><mtext mathvariant="normal">U</mtext></msubsup><mo>:=</mo><msubsup><mi>ψ</mi><mi>i</mi><mo>⋆</mo></msubsup></mrow><annotation encoding="application/x-tex">\psi^{\text{U}}_i := \psi_i^\star</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb82"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitNBreak3</span> <span class="op">&lt;-</span></span>
<span>    <span class="fu"><a href="../reference/TVGEV.html">TVGEV</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, response <span class="op">=</span> <span class="st">"TXMax"</span>, date <span class="op">=</span> <span class="st">"Date"</span>,</span>
<span>          design <span class="op">=</span> <span class="fu"><a href="../reference/breaksX.html">breaksX</a></span><span class="op">(</span>date <span class="op">=</span> <span class="va">Date</span>, breaks <span class="op">=</span> <span class="st">"1970-01-01"</span>, degree <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>          loc <span class="op">=</span> <span class="op">~</span> <span class="va">t1</span> <span class="op">+</span> <span class="va">t1_1970</span>,</span>
<span>          estim <span class="op">=</span> <span class="st">"nloptr"</span>,</span>
<span>          coefLower <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mu_t1"</span> <span class="op">=</span> <span class="op">-</span><span class="fl">0.02</span>, <span class="st">"xi_0"</span> <span class="op">=</span> <span class="op">-</span><span class="fl">0.2</span><span class="op">)</span>,</span>
<span>          coefUpper <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mu_t1"</span> <span class="op">=</span> <span class="op">-</span><span class="fl">0.02</span>, <span class="st">"xi_0"</span> <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in MLE.TVGEV(object = tv, y = NULL, psi0 = psi0, estim = estim, : some</span></span>
<span><span class="co">## estimated parameters at the bounds, inference results are misleading</span></span></code></pre>
<div class="sourceCode" id="cb84"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">fitNBreak3</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##        mu_0       mu_t1  mu_t1_1970     sigma_0        xi_0 </span></span>
<span><span class="co">## 32.13623265 -0.02000000  0.07108756  1.75700613 -0.18234029</span></span></code></pre>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Coles_ExtremeValues" class="csl-entry">
Coles, Suart. 2001. <em><span class="nocase">An Introduction to
Statistical Modeling of Extreme Values</span></em>. Springer. <a href="https://doi.org/10.1007/978-1-4471-3675-0" class="external-link">https://doi.org/10.1007/978-1-4471-3675-0</a>.
</div>
<div id="ref-CoxSnell_GeneralResiduals" class="csl-entry">
Cox, David R., and E. Joyce Snell. 2018. <span>“A General Definition of
Residuals.”</span> <em>Journal of the Royal Statistical Society: Series
B</em> 30 (2): 248–65. <a href="https://doi.org/10.1111/j.2517-6161.1968.tb00724.x" class="external-link">https://doi.org/10.1111/j.2517-6161.1968.tb00724.x</a>.
</div>
<div id="ref-Rpack_extRemes" class="csl-entry">
Gilleland, Eric, and Richard W. Katz. 2016. <span>“<span class="nocase">extRemes 2.0: An Extreme Value Analysis Package in
R</span>.”</span> <em>Journal of Statistical Software</em> 72 (8): 1–39.
<a href="https://doi.org/10.18637/jss.v072.i08" class="external-link">https://doi.org/10.18637/jss.v072.i08</a>.
</div>
<div id="ref-pack_lubridate" class="csl-entry">
Grolemund, Garett, and Hadley Wickham. 2011. <span>“Dates and Times Made
Easy with <span class="nocase">lubridate</span>.”</span> <em>Journal of
Statistical Software</em> 40 (3): 1–25. <a href="https://doi.org/10.18637/jss.v040.i03" class="external-link">https://doi.org/10.18637/jss.v040.i03</a>.
</div>
<div id="ref-KatzEtAl_ExtremesHydrology" class="csl-entry">
Katz, Richard W., Marc B. Parlange, and Philippe Naveau. 2002.
<span>“Statistics of Extremes in Hydrology.”</span> <em>Advances in
Water Resources</em> 25 (8): 1287–1304. <a href="https://doi.org/10.1016/S0309-1708(02)00056-8" class="external-link">https://doi.org/10.1016/S0309-1708(02)00056-8</a>.
</div>
<div id="ref-PanagouliaEtAl_NonStationaryGEV" class="csl-entry">
Panagoulia, Dionysia, Polychronis Economou, and Chrysseis Caroni. 2014.
<span>“<span class="nocase">Stationary and Nonstationary Generalized
Extreme Value Modelling of Extreme Precipitation over a Mountainous Area
under Climate Change</span>.”</span> <em>Environmetrics</em> 25 (1):
29–43. <a href="https://doi.org/10.1002/env.2252" class="external-link">https://doi.org/10.1002/env.2252</a>.
</div>
<div id="ref-PareyEtAl_DifRetLev" class="csl-entry">
Parey, Sylvie and Hoang, Thi Thu Huong and Dacunha-Castelle, Didier.
2010. <span>“<span class="nocase">Different Ways to Compute Temperature
Return Levels in the Climate Change Context</span>.”</span>
<em>Environmetrics</em> 21 (7-8): 698–718. <a href="https://doi.org/10.1002/env.1060" class="external-link">https://doi.org/10.1002/env.1060</a>.
</div>
<div id="ref-RootzenKatz_DesignLife" class="csl-entry">
Rootzén, Holger, and Richard W. Katz. 2013. <span>“<span class="nocase">Design Life Level: Quantifying Risk in a Changing
Climate</span>.”</span> <em><span>Water Resources Research</span></em>
42: 5964–72. <a href="https://doi.org/10.1002/wrcr.20425" class="external-link">https://doi.org/10.1002/wrcr.20425</a>.
</div>
<div id="ref-Rpack_evd" class="csl-entry">
Stephenson, Alec G. 2002. <span>“<span class="nocase">evd: Extreme Value
Distributions</span>.”</span> <em><span>The R Journal</span></em> 2 (2):
0. <a href="http://CRAN.R-project.org/doc/Rnews/" class="external-link">http://CRAN.R-project.org/doc/Rnews/</a>.
</div>
<div id="ref-RPack_ggplot2" class="csl-entry">
Wickham, Hadley. 2016. <em><span class="nocase"><span class="nocase">ggplot2</span>: Elegant Graphics for Data
Analysis</span></em>. Springer-Verlag New York. <a href="https://doi.org/10.1007/978-0-387-98141-3" class="external-link">https://doi.org/10.1007/978-0-387-98141-3</a>.
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Yves Deville.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

      </footer>
</div>






  </body>
</html>
